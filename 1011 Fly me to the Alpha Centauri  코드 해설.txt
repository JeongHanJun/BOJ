k 만큼 이동시, k-1/k/k+1 중에 하나만 다시 이동할 수 있다.
음수 만큼의 이동은 없다
x 지점 -> y 지점으로 이동할 것이다.
이 이동횟수를 최소한으로 한다.
y지점 도착 바로 전의 이동은 1 만 이동 가능하다. 
즉 도착 직전의 이동하려면 y-1 에 위치해야 한다.

거리	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17
경로	1	11	111	121	1211	1221	12211	12221	12321	123211	123221	123321	1232221	1233221	1233321	1234321	12333221
최소값	1	2	3	3	4	4	5	5	5	6	6	6	7	7	7	7	8

최소 이동 횟수(최소값) 은 1 2 33 44 555 666 7777 8~이런식으로 진행된다.
뭔가 규칙성이 없어보이지만 자연수의 제곱수 기준으로 나눠보면

거리	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16	17
최소값	1	2	3	3	4	4	5	5	5	6	6	6	7	7	7	7	8
sqrt(거리)1	1.4	1.7	2	2.2	2.4	2.6	2.8	3	3.1	3.3	3.4	3.6	3.7	3.9	4.0	4.1

이걸 보고 눈치챌 수 잇다.
최소값은 sqrt(거리) 즉 거리의 루트값의*2 의 값과 유사하다. 더 정확히는 일단 지금까지는 거리의 루트값*2 -1 이다.
이 점을 이용해서 거리의 루트값*2 를 넘지는 않고 비슷한 값이라는 걸 이용해서 stage 라는 변수를 만든다.

stage	1	1	2	2	2	2	3	3	3	3	3	3	4	4	4	4	4	

stage 변수값은  sqrt(거리) 값의 반올림 값과 같다. 그렇다면 소수점 0.5를 기준으로 stage값 판단 가능
이점을 보면 stage 변수값은 최소값이 홀수일때 바뀐다.(최소값이 5일때 stage 값 3으로, 최소값이 7일때 stage값 4로, 최소값이 9일때 stage값 5로...)
최소값은 소수점 값 spot 이 0.5보다 작으면 stage * 2 , spot이 0.5보다 크면 과 stage * 2 - 1 이 된다.

변수선언)
double FindStage : Math.sqrt(dest) , stage를 알아내기 위해 사용
int temp  	 : double 형 FindStage 의 소수점 이하의 값을 걸러 내기 위해 사용
double spot	 : temp에서 걸러낸 소수점 이하의 값

추가적으로) 문제에서 x,y 는 2^31보다 작다고했다. 2의 16승이 65536이다.(스타크래프트 최고데미지 흠흠)
최소값이 stage * 2. stage * 2 -1 둘중 하나 이므로 stage값이 커져서 제곱시 2^31 을 넘어가는 대략 4만5천 그 이상정도?
이때는 double 형으로 형변환을 해줘야 한다.

FindStage = Math.sqrt(dest) = (int)temp + (double)spot 이다.
이를 나눠서 spot 값을 구하고 spot값이 0.5보다 작으면 stage값 = temp
0.5보다 크면 temp + 1 그 값을 result 에 저장후 출력하면 끝







